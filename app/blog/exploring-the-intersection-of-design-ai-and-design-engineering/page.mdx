# Understanding SQL Indexes: Clustered vs Non-Clustered

An index is a disk-based structure linked to a table or view that facilitates quicker row retrieval. SQL Server uses table or view columns to create keys in an index. These keys are stored in a B-tree structure that enables SQL Server to efficiently locate rows corresponding to key values.

## Clustered Index

A clustered index is created only when both the following conditions are met:

1. The data in secondary memory must be in sequential or sorted order
2. There must be a unique key value (no repeated values)

When you apply clustered indexing to a table, it performs sorting on that table. You can create only one clustered index in a table, similar to a primary key. Think of it like a dictionary where data is arranged alphabetically.

> Note: In a clustered index, the index contains a pointer to block but not direct data.

### Example Implementation

```sql
Create table Student
( 
    Roll_No int primary key, 
    Name varchar(50), 
    Gender varchar(30), 
    Mob_No bigint 
);

-- Insert sample data
insert into Students
values (4, 'Mohammed', 'Male', 01112961724);

insert into Students
values (3, 'albasel', 'Male', 01102160449);

insert into Students
values (5, 'mariam', 'female', 01216574235);
```

In this example, `Roll_No` is a primary key, automatically acting as a clustered index. The output will be produced in increasing order of roll numbers.

### Important Note
While you can have only one clustered index per table, you can create a clustered index on multiple columns (known as a composite index).

## Non-Clustered Index

The non-clustered index is comparable to a book's index. Just as a book's index contains chapter names and page numbers allowing direct access to content, a non-clustered index provides direct data access without scanning the entire table.

Key characteristics:
- Data and index are stored separately
- Multiple non-clustered indexes can exist in a table
- The index contains direct pointers to data

### Implementation Example

```sql
Create table Student
( 
    Roll_No int primary key, 
    Name varchar(50), 
    Gender varchar(30), 
    Mob_No bigint 
);

-- Insert sample data
insert into Student 
values (4, 'mohammed', 'male', 1112961724);
insert into Student 
values (3, 'albasel', 'male', 1102160449);
insert into Student 
values (5, 'mariam', 'female', 1216574235);

-- Create non-clustered index
create nonclustered index NIX_FTE_Name
on Student (Name ASC);
```

In this example, while `Roll_No` remains the primary key (clustered index), we've added a non-clustered index on the `Name` column in ascending order.

## Making the Choice: Clustered vs Non-Clustered

### When to Use Clustered Indexes
- Best for tables where range queries prioritize data retrieval efficiency
- Ideal for tables with minimal updates or static data
- Perfect when data needs to be physically ordered on disk

### When to Use Non-Clustered Indexes
- Allows query optimization without altering physical data order
- Better for frequently updated tables
- Supports multiple indexes on the same table
- Faster for insert and update operations compared to clustered indexes

## Best Practices
- Carefully analyze your query patterns
- Consider the ratio of reads to writes
- Monitor index usage and performance
- Regular maintenance of indexes is crucial
- Don't over-index - each index adds overhead to write operations